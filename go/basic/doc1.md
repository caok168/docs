# 知识点汇总
## 1. Go的逃逸分析
能引起变量逃逸到堆上的典型情况：
* 在方法内把局部变量指针返回 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。
* 发送指针或带有指针的值到channel中。在编译时，是没有办法知道哪个goroutine会在channel上接收数据。所以编译器没法知道变量什么时候才会被释放
* 在一个切片上存储指针或带指针的值。一个典型的例子就是 []*string。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。
* slice的背后数组被重新分配了，因为append时可能会超出其容量（cap）。slice初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。
* 在interface类型上调用方法。在Interface类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想象一个io.Reader类型的变量r，调用r.Read(b)会使得r的值和切片b的背后存储都逃逸掉，所以会在堆上分配。

## 2. goroutine简介
goroutine是Go语言实现的用户态线程，主要用来解决操作系统线程太“重”的问题，所谓的太重，主要表现在以下两个方面：
* （1）创建和切换太重：操作系统线程的创建和切换都需要进入内核，而进入内核所消耗的性能代价比较高，开销较大；
* （2）内存使用太重：
    - 一方面，为了尽量避免极端情况下操作系统线程栈的溢出，内核在创建操作系统线程时默认会为其分配一个较大的栈内存（虚拟地址空间，内核并不会一开始就分配这么多的物理内存），然后在大多数情况下，系统线程远远用不了这么多内存，这导致了浪费；
    - 另一方面，栈内存空间一旦创建和初始化完成之后其大小就不能再有变化，这决定了在某些特殊场景下系统线程栈还是有溢出的风险。

而相对的，用户态的goroutine则轻量的多：
* （1）goroutine是用户态线程，其创建和切换都在用户代码中完成而无需进入操作系统内核，所以其开销要远远小于系统线程的创建和切换；
* （2）goroutine启动时默认栈大小只有2K，这在多数情况下已经够用了，即使不够用，goroutine的栈也会自动扩大，同时，如果栈太大了过于浪费它还能自动收缩，这样既没有栈溢出的风险，也不会造成栈内存空间的大量浪费。

## 3. Goroutine调度策略
所谓的goroutine调度，是指程序代码按照一定的算法在适当的时候挑选出合适的goroutine并放到CPU上去运行的过程。

**三大核心问题：**
* 1.调度时机：什么时候会发生调度？
* 2.调度策略：使用什么策略来挑选下一个进入运行的goroutine？
* 3.切换机制：如何把挑选出来的goroutine放到CPU上运行？

#### schedule函数详细分析其调度策略
schedule函数分三步分别从各运行队列中寻找可运行的goroutine：
* 第一步：从全局队列中寻找goroutine。为了保证调度的公平性，每个工作线程每经过61次调度就需要优先尝试从全局运行队列中找出一个goroutine来运行，这样才能保证位于全局运行队列中的goroutine得到调度的机会。全局运行队列是所有工作线程都可以访问的，所以在访问它之前需要加锁。
* 第二步：从工作线程本地运行队列中寻找goroutine。如果不需要或不能从全局运行队列中获取到goroutine则从本地运行队列中获取。
* 第三步：从其他工作线程的运行队列中偷取goroutine。如果上一步也没有找到需要运行的goroutine，则调用findrunnable从其他工作线程的运行队列中偷取goroutine，findrunnable函数在偷取之前会再次尝试从全局运行队列和当前线程的本地运行队列中查找需要运行的goroutine。

#### 从全局运行队列中获取goroutine
从全局运行队列中获取可运行的goroutine是通过globrunqget函数来完成的，该函数的第一个参数是与当前工作线程绑定的p，第二个参数max表示最多可以从全局队列中拿多少个g到当前工作线程的本地运行队列中来。

globrunqget函数首先会根据全局运行队列中goroutine的数量，函数参数max以及_p_的本地队列的容量计算出到底应该拿多少个goroutine，然后把第一个g结构体对象通过返回值的方式返回给调用函数，其它的则通过runqput函数放入当前工作线程的本地运行队列。

值得一提的是，计算应该从全局运行队列中拿走多少个goroutine时根据p的数量（gomaxprocs）做了负载均衡。

#### 从工作线程本地运行队列中获取goroutine
工作线程的本地运行队列其实分为两个部分，一部分是由p的runq、runqhead和runqtail这三个成员组成的一个无锁循环队列，该队列最多可包含256个goroutine；另一部分是p的runnext成员，一个指向g结构体对象的指针，它最多只包含一个goroutine。

从本地运行队列中寻找goroutine是通过runqget函数完成的，寻找时，代码首先查看runnext成员是否为空，如果不为空则返回runnext所指的goroutine，并把runnext成员清零，如果runnext为空，则继续从循环队列中查找goroutine。

注意：
* 从循环队列中拿goroutine使用了cas操作
* 代码中对runqhead的操作使用了atomic.LoadAcq和atomic.CasRel

#### 从其他工作线程的本地队列中盗取goroutine的过程

尽力去各个运行队列中寻找goroutine，如果实在找不到则进入睡眠状态。

* 第一点，工作线程M的自旋状态（spinning）。工作线程在从其它工作线程的本地运行队列中盗取goroutine时的状态称为自旋状态。
    - 当前M在去其它p的运行队列盗取goroutine之前把spinning标志设置成了true，同时增加处于自旋状态的M的数量，而盗取结束之后则把spinning标志还原为false，同时减少处于自旋状态的M的数量
    - 从后面的分析我们可以看到，当有空闲P又有goroutine需要运行的时候，这个处于自旋状态的M的数量决定了是否需要唤醒或者创建新的工作线程
* 第二点，盗取算法。
    - 盗取过程用了两个嵌套for循环。内层循环实现了盗取逻辑，从代码可以看出盗取的实质就是遍历allp中的所有p，查看其运行队列是否有goroutine，如果有，则取其一半到当前工作线程的运行队列，然后从findrunnable返回，如果没有则继续遍历下一个p。
    - 但这里为了保证公平性，遍历allp时并不是固定的从allp[0]即第一个p开始，而是从随机位置上的p开始，而且遍历的顺序也随机化了，防止每次遍历时使用同样的顺序访问allp中的元素。



