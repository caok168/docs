# Mutex
Mutex的架构演进分成了四个阶段：
* “初版”的Mutex使用一个flag来表示锁是否被持有，实现比较简单
* 第二阶段“给新人机会”，后来照顾到新来的goroutine，所以会让新的goroutine也尽可能地先获取到锁
* 第三阶段“多给些机会”，照顾新来的和被唤醒的goroutine（自旋）；但是这样会带来饥饿问题
* 第四阶段“解决饥饿”

### 第二阶段
* 请求锁的goroutine有两类
    * 一类是新来请求锁的goroutine；
    * 另一类是被唤醒的等待请求锁的goroutine
* 锁的状态也有两种
    * 加锁
    * 未加锁

|请求锁的goroutine |当前锁被持有|当前锁未被持有|
|:----- |:----- |:-----|
|新来的goroutine | waiter++;休眠 | 获取到锁 |
|被唤醒的goroutine| 清除mutexWoken标志；重新休眠，加入等待队列 | 清除mutexWoken标志；获取到锁|

相对于初版的设计，这次的改动主要就是，新来的goroutine也有机会先获取到锁，甚至一个goroutine可以连续获取到锁，打破了先来先得的逻辑。

还有优化空间

### 第三阶段
如果新来的goroutine或者是被唤醒的goroutine首次获取不到锁，它们就会通过自旋（spin，通过循环不断尝试，spin的逻辑是在runtime实现的）的方式，尝试检查锁是否被释放。在尝试一定的自旋次数后，再执行原来的逻辑。

如果可以spin的话，对于临界区代码执行非常短的场景来说，这是一个非常好的优化。因为临界区的代码耗时很短，锁很快就能释放，而抢夺锁的goroutine不用通过休眠唤醒方式等待调度，直接spin几次，可能就获得了锁。

**问题**
经过几次优化，Mutex的代码越来越复杂，应对高并发争抢锁的场景也更加公平。

但是因为新来的goroutine也参与竞争，有可能每次都会被新来的goroutine抢到获取锁的机会，在极端情况下，等待中的goroutine可能会一直获取不到锁，这就是**饥饿问题**

### 第四阶段 解决饥饿
饥饿模式的最大等待时间阈值设置成了1毫秒，这就意味着，一旦等待者的时间超过了这个阈值，Mutex的处理就有可能进入饥饿模式，优先让等待者先获取到锁，新来的放到队列的最后。

Mutex可能处于两种操作模式下：
* 正常模式
    - waiter都是进入先入先出队列，被唤醒的waiter并不会直接持有锁，而是要和新来的goroutine进行竞争。新来的goroutine有先天的优势，它们正在CPU中运行，在高并发情况下，被唤醒的waiter可能比较悲剧地获取不到锁，这时，它会被插入到队列的前面。
    - 如果waiter获取不到锁的时间超过阈值1毫秒，那么，这个Mutex就进入了饥饿模式。
* 饥饿模式
    - 在饥饿模式下，Mutex的拥有者将直接把锁交给队列最前面的waiter。新来的goroutine不会尝试获取锁，即使看起来锁没有被持有，它也不会去抢，也不会spin，它会乖乖地加入到等待队列的尾部

饥饿模式转换成正常模式的条件：
* 此waiter已经是队列中的最后一个waiter了，没有其它等待锁的goroutine了；
* 此waiter的等待时间小于1毫秒。

正常模式拥有更好的性能，因为即使有等待抢锁的waiter，goroutine也可以连续多次获取到锁。

饥饿模式是对公平性和性能的一种平衡，它避免了某些goroutine长时间的等待锁。在饥饿模式下，优先对待的是那些一直在等待的waiter。

### State字段
* mutexLocked：持有锁的标记
* mutexWoken：唤醒标记
* mutexStarving：饥饿标记
* mutexWaiters：阻塞等待的waiter数量

#### 等待一个Mutex的goroutine数最大是多少？是否能满足现实的需求？
目前的设计来看取决于state的类型，目前是int32，由于3个字节代表了状态，还有:2^(32-3)-1 等于536870911，一个goroutine初始化的为2KB，约等于1024GB即1TB，目前内存体量那么大的服务还是少有的，可以满足现在的使用。

## 常见的4种错误场景
* Lock/Unlock不是成对出现
* Copy已使用的Mutex
* 重入
    - Mutex不是可重入锁
    - 因为Mutex的实现中没有记录哪个goroutine拥有这把锁。理论上，任何goroutine都可以随意地Unlock这把锁，所以没办法计算重入条件
    - 实现一个可重入锁
        * 方案一：通过hacker的方式获取到goroutine id，记录下获取锁的goroutine id，它可以实现Locker接口
        * 方案二：调用Lock/Unlock方法时，由goroutine提供一个token，用来标识它自己，而不是我们通过hacker的方式获取到goroutine id，但是，这样一来，就不满足Locker接口了
    - 可重入锁（递归锁）解决了代码重入或者递归调用带来的死锁问题，同时也有另外一个好处，就是可以要求，只有持有锁的goroutine才能unlock这个锁。
* 死锁

死锁的必要条件
* 互斥：至少一个资源是被排他性独享的，其他线程必须处于等待状态，直到资源被释放
* 持有和等待：goroutine持有一个资源，并且还在请求其他goroutine持有的资源，也就是咱们常说的“吃着碗里，看着锅里”的意思
* 不可剥夺：资源只能由持有它的goroutine来释放
* 环路等待：一般来说，存在一组等待进程，P={P1,P2,...,PN},P1等待P2持有的资源，依次类推，最后是PN等待P1持有的资源，这就形成了一个环路等待的死结。

