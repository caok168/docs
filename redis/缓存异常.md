# 缓存异常（上）：如何解决缓存和数据库的数据不一致的问题？

## 如何解决数据不一致问题？
* 重试机制

具体来说，可以把要删除的缓存值或者是要更新的数据库值暂存到消息队列中（例如Kafka消息队列）。当应用没有能够成功地删除缓存值或者更新数据库值时，可以从消息队列中重新读取这些值，然后再次进行删除或更新。

如果能够成功地删除或更新，我们就要把这些值从消息队列中去除，以免重复操作，此时，就可以保证数据库和缓存的数据一致了。否则的话，需要再次进行重试。如果重试超过一定次数，还是没有成功，就需要向业务层发送报错信息了。

### **其他情况**

上面说的是在更新数据库和删除缓存值的过程中，其中一个操作失败的情况，实际上，即使这两个操作第一次执行时都没有失败，当有大量并发请求时，应用还是有可能读到不一致的数据。

* 先删除缓存的方案
    - 延迟双删
    ```
    redis.delKey(X)
    db.update(X)
    Thread.sleep(N)
    redis.delKey(X)
    ```
* 先更新数据库值，再删除缓存值
    - 在这种情况下，如果其他线程并发读缓存的请求不多，那么，就不会有很多请求读到旧值。而且，也会很快删除缓存值

### 总结
在大多数业务场景下，我们会把Redis作为只读缓存使用。我们既可以先删除缓存值再更新数据库，也可以先更新数据库再删除缓存。

建议：优先使用先更新数据库再删除缓存的方法，原因主要有两点：
* 先删除缓存值再更新数据库，有可能导致请求因缓存缺失而访问数据库，给数据库带来压力；
* 如果业务应用中读取数据库和写缓存的时间不好估算，那么，延迟双删中的等待时间就不好设置。

不过，当使用先更新数据库再删除缓存时，也有个地方需要注意，如果业务层要求必须读取一致的数据，那么，我们就需要再更新数据库时，先在Redis缓存客户端暂存并发请求，等数据库更新完、缓存值删除后，再读取数据，从而保证数据一致性。



## 在写写并发中会导致数据库和缓存的不一致

**需要先加分布式锁**

