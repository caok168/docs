# Redis持久化

Redis的持久化主要有两大机制，即AOF（Append Only File）日志和RDB快照。

### AOF日志是如何实现的？

数据库的写前日志（Write Ahead Log，WAL），在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复。

不过AOF日志正好相反，是写后日志，Redis是先执行命令，把数据写入内存，然后才记录日志。
* 为了避免额外的检查开销，Redis在向AOF里面记录日志的时候，并不会先去对这些命令进行语法检查。如果先记录日志出错的话，Redis在恢复数据时，就可能会出错。
* 写后日志这种方式，就是先让系统执行命令，只有命令执行成功，才会被记录到日志中，否则，系统就会直接向客户端报错。
* 是在命令后才记录日志，所以不会阻塞当前的写操作。

### 三种写回策略
* Always
* Everysec
* No

### AOF文件过大带来的性能问题
* 1. 文件系统本身对文件大小有限制，无法保存过大的文件；
* 2. 如果文件太大，之后再往里面追加命令记录的话，效率也会变低；
* 3. 如果发生宕机，AOF中记录的命令要一个个被重复执行，用于故障恢复，如果日志文件太大，整个恢复过程就会非常慢，这会影响到Redis的正常使用。

### 日志文件太大了怎么办？
* AOF重写机制
    - 多变一
    - 虽然AOF重写后，日志文件会缩小，但是，要把整个数据库的最新数据的操作日志都写回磁盘，仍然是一个非常耗时的过程。
    - 和AOF日志由主线程写回不同，重写过程是由后台子进程bgrewriteaof来完成的，是为了避免阻塞主线程，导致数据库性能下降。

重写的过程总结为“一个拷贝，两处日志”

每次AOF重写时，Redis会先执行一个内存拷贝，用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。

而且，因为Redis采用额外的线程进行数据重写，所以这个过程并不会阻塞主线程。

### **问题**
* 1. AOF日志重写的时候，是由bgrewriteaof子进程来完成的，不用主线程参与，我们今天说的非阻塞也是指子进程的执行不阻塞主线程。但是，你觉得，这个重写过程有没有其他潜在的阻塞风险呢？如果有的话，会在哪里阻塞？
    - fork子进程，fork这个瞬间一定是会阻塞主线程的
    - fork出的子进程指向与父进程相同的内存地址空间，此时子进程就可以执行AOF重写，把内存中的所有数据写入到AOF文件中。

* 2. AOF重写也有一个重写日志，为什么它不共享使用AOF本身的日志呢？
    - 一个原因是父子进程写同一个文件必然会产生竞争问题，控制竞争就意味着会影响父进程的性能。
    - 二是如果AOF重写过程中失败了，那么原本的AOF文件相当于被污染了，无法做恢复使用。


## RDB
Redis提供了两个命令生成RDB文件，分别为save和bgsave。
* save：在主线程中执行，会导致阻塞；
* bgsave：创建一个子进程，专门用于写入RDB文件，避免了主线程的阻塞，这也是Redis RDB文件生成的默认配置。

Redis会借助操作系统提供的写时复制技术（Copy-On-Write，COW），在执行快照的同时，正常处理写操作。

虽然bgsave执行时不阻塞主线程，但是，如果频繁地执行全量快照，也会带来两方面的开销。
* 一方面，频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，容易造成恶性循环。
* 另一方面，bgsave子进程需要通过for可操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork这个创建过程本身会阻塞主线程，而且，主线程的内存越大，阻塞时间越长。如果频繁fork出bgsave子进程，这就会频繁阻塞主线程了。

使用增量快照：就需要使用额外的元数据去记录哪些数据被修改了，这会带来额外的空间开销问题。

Redis 4.0中提出了一个混合使用AOF日志和内存快照的方法。
简单来说，内存快照以一定的频率执行，在两次快照之间，使用AOF日志记录这期间的所有命令操作。




