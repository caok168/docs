# 白话容器基础（三）：深入理解容器镜像

Mount Namespace修改的，是容器进程对文件系统“挂载点”的认知。

这也就意味着，只有在“挂载”这个操作发生之后，进程的视图才会被改变。而在此之前，新创建的容器会直接继承宿主机的各个挂载点。

Mount Namespace跟其他Namespace的使用略有不同的地方：它对容器进程视图的改变，一定是伴随着挂载操作（mount）才能生效。

Mount Namespace基于对chroot的不断改良才被发明出来的，它也是Linux操作系统里的第一个Namespace。

而这个挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，就是所谓的“容器镜像”。它还有一个更为专业的名字,叫作：rootfs（根文件系统）。

所以，一个最常见的rootfs，或者说是容器镜像，会包括如下所示的一些目录和文件，比如 /bin,/etc/,/proc等等。

对Docker项目来说，它最核心的原理实际上就是为待创建的用户进程：
* 启用Linux Namespace配置；
* 设置指定的Cgroups参数；
* 切换进程的根目录(Change Root)。

这样，一个完整的容器就诞生了。不过，Docker项目在最后一步的切换上会优先使用pivot_root系统调用，如果系统不支持，才会使用chroot。这两个系统调用虽然功能类似，但是也有细微的差别。

需要明确的是，rootfs只是一个操作系统所包含的文件、配置和目录，并不包含操作系统的内核。在Linux操作系统中，这两部分是分开存放的，操作系统只有在开机启动时才会加载指定版本的内核镜像。

所以说，rootfs只包括了操作系统的“躯壳”，并没有包括操作系统的“灵魂”。

由于rootfs里打包的不只是应用，而是整个操作系统的文件和目录，也就意味着，应用以及它运行所需要的所有依赖，都被封装在了一起。

镜像的层都放在/var/lib/docker/aufs/diff目录下，然后被联合挂载在/var/lib/docker/aufs/mnt里面。

容器的rootfs由三部分组成：
* 只读层
* 可读写层
* init层
    * 它是一个以“-init”结尾的层，夹在只读层和读写层之间。Init层是Docker项目单独生成的一个内部层，专门用来存放 /etc/hosts、/etc/resolv.conf等信息。
    * 原因：这些文件本来属于只读的Ubuntu镜像的一部分，但是用户往往需要在启动容器时写入一些指定的值比如hostname，所以就需要在可读写层对它们进行修改。
    * 但是，这些修改往往只对当前的容器有效，我们并不希望执行docker commit时，把这些信息连同可读写层一起提交掉。
    * 所以，docker做法是，在修改了这些文件之后，以一个单独的层挂载了出来，而用户执行docker commit只会提交可读写层，所以是不包含这些内容的。

